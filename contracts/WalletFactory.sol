pragma solidity 0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";
import "./Wallet.sol";


/**
 * @dev Implementation of the wallet controller contract.
 * It aims to serve as an orchestration mechanism to generate new wallets. The main idea is that any ethereum
 * address could call the `generate` method in order to have a new address available to receive funds.
 */
contract WalletFactory is Ownable {
    using Clones for address;

    /**
     * @dev Event fired whenever the `oldMaster` address has been replaced by the `newMaster` one.
     */
    event MasterChanged(address oldMaster, address newMaster);

    /**
     * @dev Event fired whenever a new address has been generated via the `generate` method.
     */
    event AddressGenerated(address indexed generatedAddress);

    /**
     * @dev Event fired upon receiving `amount` ether from `sender`.
     */
    event EtherReceived(address indexed sender, address indexed receiver, uint amount);

    /**
     * @dev Address where all funds coming from `Wallet` contracts will be collected in.
     */
    address payable public master;

    /**
     * @dev Address where the `Wallet` implementation lies. Used for cloning so that some gas can be saved
     * in the process.
     */
    address public template;
    
    /**
     * Stored whether an address has been generated by this contract or not.
     */
    mapping(address => bool) generatedAddresses;

    constructor(address payable _master, address _template) {
        require(_template != address(0), "WalletFactory: template address cannot be zero");

        template = _template;
        setMaster(_master);
    }

    /**
     * @dev Changes the current master address for `_newMaster`.
     * This operation can only be performed by the owner.
     */
    function setMaster(address payable _newMaster) public onlyOwner {
        require(_newMaster != address(0), "WalletFactory: master address cannot be zero");

        address oldMaster = master;
        master = _newMaster;
        emit MasterChanged(oldMaster, _newMaster);
    }

    /**
     * @dev Generates a new `Wallet` contract using cloning method and returns its address.
     */
    function generate(bytes32 _salt, address[] calldata _assets) public returns (address) {
        address clone = template.cloneDeterministic(_salt);
        Wallet wallet = Wallet(payable(clone));
        wallet.setup();
        generatedAddresses[clone] = true;
        emit AddressGenerated(clone);
        for (uint i = 0; i < _assets.length; i++) {
            wallet.collect(_assets[i]);
        }
        return clone;
    }
    
    /**
     * @dev Calculates the generated address given the salt.
     */
    function computeAddress(bytes32 _salt) public view returns (address) {
        return template.predictDeterministicAddress(_salt, address(this));
    }

    /**
     * @dev Gets called by a generated address whenever ether is received
     */
    function notifyEtherReceived(address _sender, uint _amount) public {
        require(generatedAddresses[msg.sender], "WalletFactory: receiver has not been generated by the factory");
        emit EtherReceived(_sender, msg.sender, _amount);
    }
}
